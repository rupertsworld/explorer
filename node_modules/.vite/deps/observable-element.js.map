{
  "version": 3,
  "sources": ["../../../web/node_modules/observable-element/src/index.js"],
  "sourcesContent": ["class ObservableElement extends HTMLElement {\n  observe(properties, callback) {\n    const props = properties;\n    this._callbacks = {};\n    this._connected = false;\n\n    /* Functions for setting/getting props and attributes */\n\n    const canBeReflected = (value) => {\n      return ['string', 'number'].includes(typeof value);\n    };\n\n    const setProp = (name, value) => {\n      if (this.propertyChangedCallback) {\n        this.propertyChangedCallback(name, getProp(name), value);\n      }\n      this['_observable_' + name] = value;\n      reflectPropToAttributes(name, value);\n      if (this._connected) this._callbacks[name]();\n    };\n\n    const getProp = (prop) => {\n      return this['_observable_' + prop];\n    };\n\n    const reflectPropToAttributes = (prop, value) => {\n      if (canBeReflected(value)) {\n        this.setAttribute(prop, value);\n      } else {\n        this.removeAttribute(prop);\n      }\n    };\n\n    // On startup\n    props.forEach((prop) => {\n      // Add callbacks to callbacks hash\n      this._callbacks[prop] = callback.bind(this);\n\n      // Update all props/attributes on initialize\n      // Prefer props, then attributes\n      if (this[prop]) {\n        setProp(prop, this[prop]);\n      } else if (this.getAttribute(prop) !== null) {\n        setProp(prop, this.getAttribute(prop));\n      }\n    });\n\n    // Whenever props are accessed or set\n    props.forEach((prop) => {\n      Object.defineProperty(this, prop, {\n        get() {\n          return getProp(prop);\n        },\n        set(value) {\n          setProp(prop, value);\n        },\n      });\n    });\n\n    /* Component lifecycle */\n\n    const observer = new MutationObserver((mutationsList) => {\n      mutationsList.forEach((mutation) => {\n        if (mutation.type === 'attributes') {\n          // When any attributes change, call the attributeChangedCallback\n          // and set the props. We need this because there's no static\n          // observedAttributes array.\n          const name = mutation.attributeName;\n          const attribute = this.getAttribute(name);\n          const prop = getProp(name);\n\n          // Abort if there is no need for attribute change\n          // if both prop and attribute are undefined, or if\n          // they're already synced\n          if (\n            attribute === prop ||\n            (typeof prop === 'number' && attribute === prop.toString()) ||\n            (!canBeReflected(prop) && attribute === null)\n          ) {\n            return;\n          }\n\n          if (this.attributeChangedCallback) {\n            this.attributeChangedCallback(name, prop, attribute);\n          } else {\n            setProp(name, attribute, true);\n          }\n        } else if (\n          mutation.type === 'childList' &&\n          mutation.addedNodes.length > 0\n        ) {\n          // When element connects, call the prop render functions\n          this._connected = true;\n          props.forEach((prop) => {\n            if (this[prop] !== undefined) this._callbacks[prop]();\n          });\n        }\n      });\n    });\n\n    observer.observe(this, { attributes: true, childList: true });\n  }\n}\n\nexport { ObservableElement };\n"],
  "mappings": ";AAAA,IAAM,oBAAN,cAAgC,YAAY;AAAA,EAC1C,QAAQ,YAAY,UAAU;AAC5B,UAAM,QAAQ;AACd,SAAK,aAAa,CAAC;AACnB,SAAK,aAAa;AAIlB,UAAM,iBAAiB,CAAC,UAAU;AAChC,aAAO,CAAC,UAAU,QAAQ,EAAE,SAAS,OAAO,KAAK;AAAA,IACnD;AAEA,UAAM,UAAU,CAAC,MAAM,UAAU;AAC/B,UAAI,KAAK,yBAAyB;AAChC,aAAK,wBAAwB,MAAM,QAAQ,IAAI,GAAG,KAAK;AAAA,MACzD;AACA,WAAK,iBAAiB,IAAI,IAAI;AAC9B,8BAAwB,MAAM,KAAK;AACnC,UAAI,KAAK;AAAY,aAAK,WAAW,IAAI,EAAE;AAAA,IAC7C;AAEA,UAAM,UAAU,CAAC,SAAS;AACxB,aAAO,KAAK,iBAAiB,IAAI;AAAA,IACnC;AAEA,UAAM,0BAA0B,CAAC,MAAM,UAAU;AAC/C,UAAI,eAAe,KAAK,GAAG;AACzB,aAAK,aAAa,MAAM,KAAK;AAAA,MAC/B,OAAO;AACL,aAAK,gBAAgB,IAAI;AAAA,MAC3B;AAAA,IACF;AAGA,UAAM,QAAQ,CAAC,SAAS;AAEtB,WAAK,WAAW,IAAI,IAAI,SAAS,KAAK,IAAI;AAI1C,UAAI,KAAK,IAAI,GAAG;AACd,gBAAQ,MAAM,KAAK,IAAI,CAAC;AAAA,MAC1B,WAAW,KAAK,aAAa,IAAI,MAAM,MAAM;AAC3C,gBAAQ,MAAM,KAAK,aAAa,IAAI,CAAC;AAAA,MACvC;AAAA,IACF,CAAC;AAGD,UAAM,QAAQ,CAAC,SAAS;AACtB,aAAO,eAAe,MAAM,MAAM;AAAA,QAChC,MAAM;AACJ,iBAAO,QAAQ,IAAI;AAAA,QACrB;AAAA,QACA,IAAI,OAAO;AACT,kBAAQ,MAAM,KAAK;AAAA,QACrB;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAID,UAAM,WAAW,IAAI,iBAAiB,CAAC,kBAAkB;AACvD,oBAAc,QAAQ,CAAC,aAAa;AAClC,YAAI,SAAS,SAAS,cAAc;AAIlC,gBAAM,OAAO,SAAS;AACtB,gBAAM,YAAY,KAAK,aAAa,IAAI;AACxC,gBAAM,OAAO,QAAQ,IAAI;AAKzB,cACE,cAAc,QACb,OAAO,SAAS,YAAY,cAAc,KAAK,SAAS,KACxD,CAAC,eAAe,IAAI,KAAK,cAAc,MACxC;AACA;AAAA,UACF;AAEA,cAAI,KAAK,0BAA0B;AACjC,iBAAK,yBAAyB,MAAM,MAAM,SAAS;AAAA,UACrD,OAAO;AACL,oBAAQ,MAAM,WAAW,IAAI;AAAA,UAC/B;AAAA,QACF,WACE,SAAS,SAAS,eAClB,SAAS,WAAW,SAAS,GAC7B;AAEA,eAAK,aAAa;AAClB,gBAAM,QAAQ,CAAC,SAAS;AACtB,gBAAI,KAAK,IAAI,MAAM;AAAW,mBAAK,WAAW,IAAI,EAAE;AAAA,UACtD,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAED,aAAS,QAAQ,MAAM,EAAE,YAAY,MAAM,WAAW,KAAK,CAAC;AAAA,EAC9D;AACF;",
  "names": []
}
